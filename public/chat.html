<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GPTs Help â€” Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    /* â€¦ your existing CSS remains unchanged â€¦ */
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
</head>
<body>
  <!-- all your sidebar, main, composer, modal HTML stays identical -->
  <script>
    /* ... all your existing JS up to before the submit handler ... */

    function shouldAutoTitleFor(convId){
      if (!convId) return true;
      if (pendingAutoTitle.has(convId)) return true;
      const t = (convTitleCache[convId]||'').trim().toLowerCase();
      return t === 'new chat' || t === 'untitled' || t === '';
    }

    /* Auto-title wrapper */
    async function maybeAutoTitle(convId, sourceText, prefix = "") {
      try {
        if (!shouldAutoTitleFor(convId)) return;
        const autoTitle = makeTitleFrom(sourceText, prefix);
        await api.renameConv(convId, autoTitle);
        convTitleCache[convId] = autoTitle;
        pendingAutoTitle.delete(convId);
        await loadConversations(convId);
      } catch (err) {
        console.warn("Auto-title failed", err);
      }
    }

    /* Submit text */
    document.getElementById('composer').addEventListener('submit', async (e)=>{e.preventDefault();
      if (readOnly) return;
      const text = (promptEl.value||'').trim();
      if (!text) return;

      try {
        const me = await api.me();
        if (me?.status==='ok' && me.user?.email && !me.user?.verified) {
          renderVerifyMessage(); promptEl.value=''; autoresize(); return;
        }
      } catch {}

      renderMessage('user', text, now()); scrollToBottom();
      sendBtn.disabled=true; photoBtn.disabled=true; promptEl.disabled=true; statusEl.textContent='Thinkingâ€¦';
      try {
        const payload = { message:text, gptType:'math' };
        if (currentConvId) payload.conversationId=currentConvId;
        const res = await api.chat(payload);

        if (!currentConvId && res.conversationId) {
          currentConvId = res.conversationId;
          convTitleCache[currentConvId] = 'New chat';
          pendingAutoTitle.add(currentConvId);
          await loadConversations(currentConvId);
        }

        /* auto-title */
        await maybeAutoTitle(currentConvId, text);

        if (res.__status === 403 && (res.status==='verify_required' || res.message?.toLowerCase().includes('verify'))) {
          renderVerifyMessage();
        } else if (res.__status === 402) {
          renderQuotaMessage(res.message, res.upgradeLink);
        } else if (res.__status && res.__status !== 200) {
          renderMessage('assistant', res.message || 'Sorry, something went wrong. Please try again.');
        } else {
          renderMessage('assistant', typeof res?.response === 'string' ? res.response : '');
        }
        scrollToBottom();
      } catch {
        renderMessage('assistant','Sorry, something went wrong. Please try again.'); scrollToBottom();
      } finally {
        promptEl.value=''; autoresize();
        sendBtn.disabled=false; photoBtn.disabled=false; promptEl.disabled=false; promptEl.focus(); statusEl.textContent='';
      }
    });

    /* Photo Solve */
    photoBtn.addEventListener('click',()=> !readOnly && photoFile.click());
    photoFile.addEventListener('change', async ()=>{if (readOnly) return;
      const file = photoFile.files && photoFile.files[0];
      if (!file) return;

      try {
        const me = await api.me();
        if (me?.status==='ok' && me.user?.email && !me.user?.verified){
          renderVerifyMessage(); photoFile.value=''; return;
        }
      } catch {}

      const okTypes=['image/png','image/jpeg','image/jpg','image/webp'];
      if(!okTypes.includes(file.type)){ alert('Please choose a PNG, JPG, or WEBP image.'); photoFile.value=''; return; }
      if(file.size>6*1024*1024){ alert('Image is larger than 6MB.'); photoFile.value=''; return; }

      const note = prompt('Optional: add a short note. Leave blank if not needed.') || '';
      const objUrl=URL.createObjectURL(file);
      renderImageMessage(note ? `ðŸ“· (with note) ${note}` : 'ðŸ“· Photo uploaded', objUrl);
      scrollToBottom();

      sendBtn.disabled=true; photoBtn.disabled=true; promptEl.disabled=true; statusEl.textContent='Solvingâ€¦';
      try {
        const fd=new FormData();
        fd.append('image', file);
        fd.append('gptType', 'math');
        if (note) fd.append('attempt', note);
        if (currentConvId) fd.append('conversationId', currentConvId);

        const wasNew = !currentConvId;
        const res = await api.photoSolve(fd);

        if (wasNew && res.conversationId){
          currentConvId=res.conversationId;
          convTitleCache[currentConvId]='New chat';
          pendingAutoTitle.add(currentConvId);
          await loadConversations(currentConvId);
        }

        /* auto-title for photos */
        await maybeAutoTitle(currentConvId, note || "Photo", "Photo:");

        if (res.__status === 403 && (res.status==='verify_required' || res.message?.toLowerCase().includes('verify'))){
          renderVerifyMessage();
        } else if (res.__status === 402){
          renderQuotaMessage(res.message, res.upgradeLink);
        } else if (res.__status && res.__status !== 200){
          renderMessage('assistant', res.message || 'Photo solve failed. Please try again.');
        } else {
          const out = (typeof res?.response === 'string') ? res.response : 'No response text returned.';
          renderMessage('assistant', out);
        }
        scrollToBottom();
      } catch {
        renderMessage('assistant','Photo solve failed. Please try another image.');
        scrollToBottom();
      } finally {
        URL.revokeObjectURL(objUrl);
        photoFile.value='';
        sendBtn.disabled=false; photoBtn.disabled=false; promptEl.disabled=false; promptEl.focus();
        statusEl.textContent='';
      }
    });

    /* ... rest of your code (new chat, user menu, read-only, init, etc.) stays unchanged ... */
  </script>
</body>
</html>